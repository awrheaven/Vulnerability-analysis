## 前言

漏洞利用系列教程的第一部分. 这部分涉及漏洞利用最基本的内容, 比如漏洞利用需要什, 漏洞利用基本概念, 还有如果要成功执行shellcode, 我们需要记住的几件事. 本系列教程不涉及如何发现软件的bug, 相反, 每一部分都有一个有漏洞的程序, 通过特定的技术, 可以成功利用它.我会在适当的时候介绍从’溢出覆盖返回地址’ 到 ’ROP(返回导向编程)’等一系列技术. 值得一提的是, 这个教程不会涉及所有漏洞利用所有的细节;通过(1)能节约我一些时间(2)能帮助热爱学习的参与进来

这里我尤其要感谢 Offensive Security and Corelan, 谢谢你们使我染上这神奇而又痛苦的毒瘾.

## (1)我们需要什么
Immunity Debugger
Immunity Debugger类似于Ollydbg, 但是它支持python, 有助于我们在漏洞利用中运行一些脚本. 它完全免费;点上面 ‘下载’ 链接然后填上一些虚假的信息就可以下载到Immunity Debugger.
Mona.py
Mona是一个很好的工具, 它的很多功能使得漏洞利用更快速和稳定. 当然我不会介绍所有的参数, 在教程接下来的部分我们将会用到它们. 下载然后把它放到Immunity’s PyCommands文件夹.
Pvefindaddr.py – 下载
Pvefindaddr是mona’s的老版本. 我知道它有点过时了, 只是它有一些有用的功能没有集成到mona中. 下载然后把它放到Immunity’s PyCommands文件夹.
Metasploit Framework
我们将经常使用Metasploit 框架,最重要的是我们能从这个msf得到漏洞利用的shellcode,还有, 我们需要一个接收任何连接的平台, 通过反连进行漏洞利用. 我建议你用Backtrack, 因为它集成了我们需要的所有东西, 并且你可以随意设置metasplot, 使它工作在你认为合适的方式.
虚拟机
基本上会选择VirtualBox(免费)或者Vmware(收费). 如果有条件, 我建议用Vmware; 聪明的人可能不需要付钱;)). 与之配套, 我们需要装上几个32位的操作系统(最常用的是Windows xp sp3 和 Windows 7).

## (2)溢出
对于这个教程的, 我认为该简单的要讲的简单，反义也是. 一般来说, 如果我们想写一个漏洞利用程序, 首先需要找到一个有溢出漏洞的程序.通常, 这些bug会是缓冲区溢出(内存被比它大的数据覆盖)或者堆溢出(通常是超长数据超出堆得范围). 溢出发生时,我们需要知道两件事;

(1)需要覆写eip的缓冲区(当前指令指针),

(2)一个指向我们缓冲区的寄存器. 下面是x86 cpu寄存器列表和它们的功能. 记住, 任何一个寄存器都可以指向我们的缓冲区(shellcode).

EAX –用于算术运算和累加, 保存算术运算结果和函数的返回值

EBX – 基地址寄存器, 指向DS段. 用于保存程序的基地址.

ECX - 计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。

EDX –通用寄存器. 也用于I/O操作. 扩展EAX到64位

ESI - 源标索引寄存器. 指向DS指向的数据段. 在字符串或数组操作时用作偏移. 是读取数据的源地址

EDI - 目标索引寄存器. 指向ES指向的数据段.  在字符串或数组操作时用作偏移. 保存字符串复制的目的地址

EBP –基址指针.指向栈上的数据. 指向当前栈帧底部. 用于引用局部变量.

ESP –堆栈指针.指向当前栈帧顶部. 用于引用局部变量

EIP – 指令指针(保存将要被执行指令的地址)

## (3)它如何工作?
基本上
(1)  我们有一个缓冲区溢出程序(通过超长字符串)

(2)  这个字符串会覆盖eip, 它的地址保存在某个寄存器

(3)  找到一个指向这个寄存器的指针

(4)  用这个指针覆盖原来的eip

(5)  当程序返回的时候最终会跳去执行我们的指令

(6)  把shellcode放在某个寄存器所指向的地址
实际上我们劫持了程序, 把eip指向我们可控的区域. 能做到这, 我们就可以远程执行任意代码. 这似乎有点简单了,但这就是漏洞利用的基本思想.
